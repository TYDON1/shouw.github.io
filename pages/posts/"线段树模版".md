---
title: "线段树模版"
date: "2026-02-01 13:49:13"
author: shouw
katex: true
categories:
  - 模版
email: KijinSeija@shouw.blog
readmore: true
tags:
  - 编程
  - 算法竞赛
  - 模版
---

## 线段树模版

```cpp
#include <bits/stdc++.h>
#define int long long
#define endl "\n"

using namespace std;

/**
 * Tag 结构体：用于维护“懒标记”（Lazy Tag）
 * 在区间修改时，我们不立即更新到叶子节点，而是先存放在标记里。
 */
struct Tag {
    int add = 0; // 这里的 add 表示区间加法的增量

    // apply 函数：实现标记的合并（即当一个区间已经有标记时，叠加新的标记）
    void apply(const Tag &t) {
        add += t.add;
    }
};

/**
 * Info 结构体：维护线段树每个节点存储的具体信息
 */
struct Info {
    // 初始化最大值为负无穷，最小值为正无穷
    int max_v = -2e18, min_v = 2e18;

    Info() {}
    // 构造函数：用于叶子节点的初始化，此时最大值和最小值都是它本身
    Info(int v) : max_v(v), min_v(v) {}

    // apply 函数：将标记 Tag 的修改应用到当前的 Info 数据上
    void apply(const Tag &t) {
        // 如果当前节点不是空节点（无效值），则执行加法更新
        if (max_v != -2e18) max_v += t.add;
        if (min_v != 2e18) min_v += t.add;
    }

    // 重载 + 运算符：实现 Push Up 操作，即如何由左右两个子节点合并出父节点的信息
    friend Info operator+(const Info &a, const Info &b) {
        Info res;
        res.max_v = max(a.max_v, b.max_v); // 父节点最大值等于子节点最大值的较大者
        res.min_v = min(a.min_v, b.min_v); // 父节点最小值等于子节点最小值的较小者
        return res;
    }
};

/**
 * Segment_Tree 类：通用线段树模板
 * @tparam Info 节点信息类
 * @tparam Tag 懒标记类
 */
template<class Info, class Tag>
struct Segment_Tree {
    int n;
    vector<Info> info; // 存储树节点的数组
    vector<Tag> tag;   // 存储懒标记的数组

    Segment_Tree(): n(0) {}

    // 构造函数：指定大小 n 和默认初始信息 v
    Segment_Tree(int n_, Info v_ = Info()) {
        init(n_, v_);
    }

    // 构造函数：直接传入一个 vector 进行初始化
    template<class T>
    Segment_Tree(vector<T> init_) {
        init(init_);
    }

    void init(int n_, Info v_ = Info()) {
        init(vector<Info>(n_, v_));
    }

    // 核心初始化函数
    template<class T>
    void init(vector<T> init_) {
        n = init_.size();
        // 计算空间：通常开 4n 空间。这里使用了位运算来确定数组大小
        int m = 1;
        while (m < n) m <<= 1;
        info.assign(m << 2, Info());
        tag.assign(m << 2, Tag());

        // 递归构建线段树
        function<void(int, int, int)> build = [&](int p, int l, int r) {
            if (l == r) {
                info[p] = init_[l];
                return;
            }
            int m = (l + r) >> 1;
            build(2 * p, l, m);
            build(2 * p + 1, m + 1, r);
            pull(p); // 向上合并信息
        };
        build(1, 0, n - 1);
    }

    // apply：对节点 p 应用标记 v，同时更新该节点的 info 和 tag
    void apply(int p, const Tag &v) {
        info[p].apply(v);
        tag[p].apply(v);
    }

    // push：下传标记（Push Down）
    // 将当前节点的懒标记传递给左右儿子，然后清空当前标记
    void push(int p) {
        apply(2 * p, tag[p]);
        apply(2 * p + 1, tag[p]);
        tag[p] = Tag();
    }

    // pull：上传信息（Push Up）
    // 根据左右儿子节点的信息更新当前节点
    void pull(int p) {
        info[p] = info[p * 2] + info[p * 2 + 1];
    }

    // modify：区间修改
    // 在 [l, r] 范围内查找并修改落在 [x, y] 间的节点
    void modify(int p, int l, int r, int x, int y, const Tag &v) {
        if (l >= x && r <= y) {
            apply(p, v);
            return;
        }
        push(p); // 操作前先下传标记
        int m = (l + r) >> 1;
        if (x <= m) modify(2 * p, l, m, x, y, v);
        if (y > m) modify(2 * p + 1, m + 1, r, x, y, v);
        pull(p); // 修改完成后向上更新
    }

    void modify(int l, int r, const Tag &v) {
        if (l > r) return;
        modify(1, 0, n - 1, l, r, v);
    }

    // query：区间查询
    // 返回 [x, y] 范围内的合并后的 Info 信息
    Info query(int p, int l, int r, int x, int y) {
        if (l > y || r < x) return Info(); // 不在范围内返回空
        if (l >= x && r <= y) return info[p];
        push(p);
        int m = (l + r) >> 1;
        return query(2 * p, l, m, x, y) + query(2 * p + 1, m + 1, r, x, y);
    }

    void query(int l, int r) {
        if (l > r) return Info();
        return query(1, 0, n - 1, l, r);
    }

    /**
     * find_first：在线段树上进行二分查找
     * 查找区间 [x, y] 内第一个满足 pred 条件的索引
     */
    template<class F>
    int find_first(int p, int l, int r, int x, int y, F &&pred) {
        // 如果当前区间完全不符合条件，或者不在查询范围内，返回 -1
        if ((l > y || r < x) || (l >= x && r <= y && !pred(info[p]))) {
            return -1;
        }
        // 如果到达叶子节点，说明找到了
        if (l == r) {
            return l;
        }
        push(p);
        int m = (l + r) >> 1;
        // 优先在左子树找
        int res = find_first(2 * p, l, m, x, y, pred);
        if (res == -1) {
            // 左子树没找到再去右子树找
            res = find_first(2 * p + 1, m + 1, r, x, y, pred);
        }
        return res;
    }

    template<class F>
    int find_first(int l, int r, F &&pred) {
        return find_first(1, 0, n - 1, l, r, pred);
    }

    /**
     * find_last：在线段树上二分查找
     * 查找区间 [x, y] 内最后一个满足 pred 条件的索引
     */
    template<class F>
    int find_last(int p, int l, int r, int x, int y, F &&pred) {
        if ((l > y || r < x) || (l >= x && r <= y && !pred(info[p]))) {
            return -1;
        }
        if (l == r) {
            return l;
        }
        push(p);
        int m = (l + r) >> 1;
        // 既然找最后一个，就优先去右子树寻找
        int res = find_last(2 * p + 1, m + 1, r, x, y, pred);
        if (res == -1) {
            res = find_last(2 * p, l, m, x, y, pred);
        }
        return res;
    }

    template<class F>
    int find_last(int l, int r, F &&pred) {
        return find_last(1, 0, n - 1, l, r, pred);
    }
};
```