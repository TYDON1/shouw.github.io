import{_ as g}from"./ValaxyMain.vue_vue_type_style_index_0_lang.WfuZKrm6.js";import{e as c,u as p,a as m}from"./chunks/vue-router.DsroaBuc.js";import{ab as F,aq as s,ak as a,af as l,ah as n,B as b,aa as f,D as y}from"./framework.BL_Vg4VX.js";import"./app.Bjm4nzdP.js";import"./chunks/dayjs.BdcnXKr1.js";import"./chunks/vue-i18n.CTYjAHa5.js";import"./chunks/pinia.z1Kk77sp.js";/* empty css                    */import"./chunks/@vueuse/motion.DbLsyMRO.js";import"./chunks/nprogress.Bru8d7fl.js";import"./YunComment.vue_vue_type_style_index_0_lang.CDVQ7zRL.js";import"./index.C5okkQwF.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang.COvD5tKW.js";import"./post.pnCXePE9.js";const C=c("/posts/“关于Docker的一些个人理解”",async i=>JSON.parse('{"title":"“关于Docker的一些个人理解与实践”","description":"","frontmatter":{"title":"“关于Docker的一些个人理解与实践”","date":"2025-10-13 07:25:07","author":"shouw","email":"KijinSeija@shouw.blog","readmore":true,"tags":["技术","网络","容器化","Docker"]},"headers":[],"relativePath":"pages/posts/“关于Docker的一些个人理解”.md","lastUpdated":1769858688000}'),{lazy:(i,e)=>i.name===e.name}),L={__name:"“关于Docker的一些个人理解”",setup(i,{expose:e}){const{data:r}=C(),k=m(),h=p(),o=Object.assign(h.meta.frontmatter||{},r.value?.frontmatter||{});return k.currentRoute.value.data=r.value,y("valaxy:frontmatter",o),globalThis.$frontmatter=o,e({frontmatter:{title:"“关于Docker的一些个人理解与实践”",date:"2025-10-13 07:25:07",author:"shouw",email:"KijinSeija@shouw.blog",readmore:!0,tags:["技术","网络","容器化","Docker"]}}),(t,u)=>{const d=g;return f(),F(d,{frontmatter:b(o)},{"main-content-md":s(()=>[...u[0]||(u[0]=[l("h2",{id:"关于docker的一些个人理解与实践",tabindex:"-1"},[n("关于Docker的一些个人理解与实践 "),l("a",{class:"header-anchor",href:"#关于docker的一些个人理解与实践","aria-label":'Permalink to "关于Docker的一些个人理解与实践"'},"​")],-1),l("p",null,[n("最近由于在自己下载一些GitHub上面的项目尝试运行，为了防止出现安装了一大堆环境而互相冲突，或者依赖版本不兼容的情况，我使用了"),l("strong",null,"Docker"),n("。Docker是一个开源的应用容器引擎，它可以将应用及其依赖项打包到一个可移植的容器中，然后发布到任何流行的Linux机器或Windows、macOS上。这极大地简化了环境配置和部署过程。")],-1),l("h3",{id:"容器端口冲突与通信问题",tabindex:"-1"},[n("容器端口冲突与通信问题 "),l("a",{class:"header-anchor",href:"#容器端口冲突与通信问题","aria-label":'Permalink to "容器端口冲突与通信问题"'},"​")],-1),l("p",null,"在项目实践中，我们有时会遇到一些端口冲突和容器间通信的问题。",-1),l("p",null,"例如，一个典型的Web应用场景：",-1),l("ol",null,[l("li",null,[l("strong",null,"前端服务"),n("（如Nginx、Web服务器）需要通过访问"),l("strong",null,"公网域名"),n("直接展示网页，所以通常需要将容器的"),l("strong",null,"80端口"),n("（HTTP）或"),l("strong",null,"443端口"),n("（HTTPS）映射到宿主机对应的端口上，以便外部用户可以直接访问。")]),l("li",null,[l("strong",null,"后端API服务"),n("（如Java、Python应用）可能也需要监听一个端口（例如"),l("strong",null,"8080"),n("或"),l("strong",null,"80"),n("）来进行服务内部通信或作为其默认监听端口。")])],-1),l("p",null,[n("如果希望后端服务也能使用"),l("strong",null,"80端口"),n("进行通信，但宿主机的"),l("strong",null,"80端口"),n("已经被前端容器映射并占用，那么将第二个容器的"),l("strong",null,"80端口"),n("也映射到宿主机"),l("strong",null,"80端口"),n("显然是不可行的，会导致端口冲突。")],-1),l("p",null,"同时，不同的Docker容器之间，如果希望它们能互相访问（通信），也需要配置正确的网络。",-1),l("p",null,[n("我们可以使用以下两种或更多方式来解决"),l("strong",null,"容器间通信"),n("以及"),l("strong",null,"宿主机端口占用"),n("的问题，使得前端和后端服务可以正常协作：")],-1),l("h3",{id:"解决方案",tabindex:"-1"},[n("解决方案 "),l("a",{class:"header-anchor",href:"#解决方案","aria-label":'Permalink to "解决方案"'},"​")],-1),l("h4",{id:"_1-使用docker自定义网络-推荐",tabindex:"-1"},[n("1. 使用"),l("strong",null,"Docker自定义网络"),n("（推荐） "),l("a",{class:"header-anchor",href:"#_1-使用docker自定义网络-推荐","aria-label":'Permalink to "1. 使用**Docker自定义网络**（推荐）"'},"​")],-1),l("p",null,"将两个或多个相关的Docker容器加入到一个自定义的桥接网络（Bridge Network）中。",-1),l("p",null,[l("strong",null,"优势"),n("：")],-1),l("ul",null,[l("li",null,[l("strong",null,"容器可以直接使用服务名或容器名互相通信"),n("，无需通过映射到宿主机的端口或查询IP地址。")]),l("li",null,[n("解决了宿主机"),l("strong",null,"80端口"),n("冲突的问题，因为容器间通信无需经过宿主机端口映射。")])],-1),l("p",null,[l("strong",null,"具体操作如下"),n("：")],-1),l("ol",null,[l("li",null,[l("p",null,[l("strong",null,"创建自定义网络"),n("：")]),l("div",{class:"language-bash"},[l("button",{title:"Copy code",class:"copy"}),l("span",{class:"lang"},"bash"),l("pre",{class:"shiki shiki-themes github-light github-dark vp-code"},[l("code",{"v-pre":""},[l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"docker"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," network"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," create"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," my_custom_network")])])]),l("button",{class:"code-block-unfold-btn"})])]),l("li",null,[l("p",null,[l("strong",null,"运行容器并指定网络"),n("：")]),l("ul",null,[l("li",null,[l("strong",null,"前端容器"),n("（需要对外提供服务，因此需要映射宿主机端口）："),l("div",{class:"language-bash"},[l("button",{title:"Copy code",class:"copy"}),l("span",{class:"lang"},"bash"),l("pre",{class:"shiki shiki-themes github-light github-dark vp-code"},[l("code",{"v-pre":""},[l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"docker"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," run"),l("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," -d"),l("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," --name"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," frontend_web"),l("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," --network"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," my_custom_network"),l("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," -p"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," 80:80"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," frontend_image")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"# -p 80:80：将宿主机的80端口映射到容器的80端口，用于用户访问。")])])]),l("button",{class:"code-block-unfold-btn"})])]),l("li",null,[l("strong",null,"后端容器"),n("（不需要对外直接暴露，只需对前端容器暴露）："),l("div",{class:"language-bash"},[l("button",{title:"Copy code",class:"copy"}),l("span",{class:"lang"},"bash"),l("pre",{class:"shiki shiki-themes github-light github-dark vp-code"},[l("code",{"v-pre":""},[l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"}},"docker"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," run"),l("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," -d"),l("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," --name"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," backend_api"),l("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," --network"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," my_custom_network"),l("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," -p"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," 8080:8080"),l("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}}," backend_image")]),n(`
`),l("span",{class:"line"},[l("span",{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"}},"# 后端容器的8080端口可以随意选择，但不需要将其映射到宿主机，或可以映射到一个高位端口（如-p 12345:8080）用于测试，但不用于生产环境的前后端通信。")])])]),l("button",{class:"code-block-unfold-btn"})])])])]),l("li",null,[l("p",null,[l("strong",null,"容器间通信"),n("： 在配置前端容器（如Nginx）时，可以"),l("strong",null,"直接使用后端容器的服务名"),n("（"),l("code",null,"backend_api"),n("）和"),l("strong",null,"容器内部端口"),n("（"),l("code",null,"8080"),n("）来进行通信和请求转发。")]),l("ul",null,[l("li",null,[n("例如，前端Nginx的配置中，代理地址可以是 "),l("code",null,"http://backend_api:8080"),n("。")])])])],-1),l("p",null,[l("strong",null,"注意"),n("："),l("code",null,"frontend_web"),n(" 和 "),l("code",null,"backend_api"),n(" 容器内部可以监听"),l("strong",null,"各自独立的80端口"),n("或其他端口，只要不冲突即可。这里的关键是"),l("strong",null,"宿主机只有一个80端口"),n("，因此"),l("strong",null,"只有一个容器"),n("可以映射到它。")],-1),l("h4",{id:"_2-使用反向代理-如nginx-traefik-进行域名-路径匹配和请求转发",tabindex:"-1"},[n("2. 使用"),l("strong",null,"反向代理"),n("（如Nginx/Traefik）进行域名/路径匹配和请求转发 "),l("a",{class:"header-anchor",href:"#_2-使用反向代理-如nginx-traefik-进行域名-路径匹配和请求转发","aria-label":'Permalink to "2. 使用**反向代理**（如Nginx/Traefik）进行域名/路径匹配和请求转发"'},"​")],-1),l("p",null,[n("这个方案与第一个方案通常是"),l("strong",null,"结合使用"),n("的，尤其是在管理多个应用和域名时，或者当一个容器需要监听多个域名/路径的请求时。")],-1),l("p",null,[l("strong",null,"具体操作"),n("：")],-1),l("ol",null,[l("li",null,[l("strong",null,"部署一个专业的反向代理容器"),n("（如Nginx/Traefik），作为所有请求的"),l("strong",null,"唯一入口"),n("。")]),l("li",null,[l("strong",null,"反向代理容器"),n("负责将"),l("strong",null,"宿主机的80/443端口"),n("映射出来，接收外部用户的所有请求。")]),l("li",null,[n("反向代理通过"),l("strong",null,"域名匹配"),n("（Host Header）或"),l("strong",null,"路径匹配"),n("（URL Path）来判断请求应该发送给哪个"),l("strong",null,"后端服务容器"),n("。")]),l("li",null,[n("将所有"),l("strong",null,"服务容器"),n("（包括前端应用、后端API）都加入到一个"),l("strong",null,"自定义网络"),n("（如"),l("code",null,"my_custom_network"),n("）中。")]),l("li",null,[n("反向代理容器通过"),l("strong",null,"服务名"),n("和"),l("strong",null,"容器内部端口"),n("（如 "),l("code",null,"backend_api:8080"),n("）将请求转发到对应的后端容器。")])],-1),l("p",null,[l("strong",null,"优势"),n("：")],-1),l("ul",null,[l("li",null,[l("strong",null,"统一的入口"),n("，易于管理 SSL/TLS 证书、负载均衡、限流等。")]),l("li",null,[n("彻底解决了宿主机端口冲突问题，因为"),l("strong",null,"所有外部请求只通过反向代理的80/443端口进入"),n("。")]),l("li",null,[n("后端服务可以完全不对外暴露任何端口（不使用"),l("code",null,"-p"),n("进行宿主机端口映射），增强安全性。")])],-1),l("p",null,[l("strong",null,"总结"),n("：在现代Docker部署中，"),l("strong",null,"自定义网络"),n("是实现容器间通信的基础，而"),l("strong",null,"反向代理"),n("则是管理多服务入口和流量分发的常用手段。")],-1)])]),"main-header":s(()=>[a(t.$slots,"main-header")]),"main-header-after":s(()=>[a(t.$slots,"main-header-after")]),"main-nav":s(()=>[a(t.$slots,"main-nav")]),"main-content-before":s(()=>[a(t.$slots,"main-content-before")]),"main-content":s(()=>[a(t.$slots,"main-content")]),"main-content-after":s(()=>[a(t.$slots,"main-content-after")]),"main-nav-before":s(()=>[a(t.$slots,"main-nav-before")]),"main-nav-after":s(()=>[a(t.$slots,"main-nav-after")]),comment:s(()=>[a(t.$slots,"comment")]),footer:s(()=>[a(t.$slots,"footer")]),aside:s(()=>[a(t.$slots,"aside")]),"aside-custom":s(()=>[a(t.$slots,"aside-custom")]),default:s(()=>[a(t.$slots,"default")]),_:3},8,["frontmatter"])}}};export{L as default,C as usePageData};
